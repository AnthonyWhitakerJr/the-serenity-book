http://cucumber.io[Cucumber] is a popular tool for automating BDD-style acceptance criteria.
Teams that practice BDD have conversations about business rules and examples to better understand the problem they are solving.
Some of these examples can be transformed into automated acceptance criteria.
Teams that use Cucumber express these acceptance criteria in a natural, human-readable form using the `given..when..then` structure:

[source,gherkin]
----
Scenario: Cash withdrawal
  Given Clive has $1000 in his current account
  When he withdraws $100 in cash
  Then his remaining balance should be $900
----

This format is known as 'Gherkin', and is widely used in Cucumber and other Cucumber-based BDD tools such as SpecFlow (for .NET) and Behave (for Python).
Gherkin is a flexible, highly readable format that can be written collaboratively with product owners to ensure that everyone is on the same page.
The loosely-structured 'Given-When-Then' format helps people focus on what they are trying to achieve, and how they will know when they get it.

Gherkin also supports tabular data formats, which is a useful and concise way of representing many domain concepts:

[source,gherkin]
----
Scenario: Transferring funds between internal accounts
  Given Clive has the following accounts:
    | Account | Balance |
    | Current | 1000    |
    | Savings | 2000    |
  When he transfers $100 from his Current account to his Savings account
  Then his new account balances should be:
    | Account | Balance |
    | Current | 900     |
    | Savings | 2100    |
----

Sometimes tables can be used to summarise several different examples of the same scenario.
For example, the following scenario illustrates the fee structure for different account types:

[source,gherkin]
----
Scenario Outline: Account Fees for different types of account
  Given Clive has an <Account Type> account with a balance of <Sample Balance>
  When the monthly fees are calculated
  Then a <Monthly Fee> monthly fee of <Sample Fee> should be deducted
  Examples:
  | Account Type | Monthly Fee | Sample Balance | Sample Fee |
  | Current      | $1.50       | 1000           | 1.50       |
  | Savings      | $0.00       | 1000           | 0.00       |
  | Investment   | 0.25%       | 1000           | 2.50       |
----

When you integrate Serenity with Cucumber,

== Versions of Cucumber

There are currently two commonly-used versions of Cucumber: Cucumber 2 and Cucumber 4.
While they both support the same _Gherkin_ notation, the way you implement the steps is a little different in each version.
When you use Serenity with Cucumber, you use a different dependency depending on the version of Cucumber you want to use.

New versions come out regularly: you can find out what the latest stable versions are [on the Serenity BDD Github home page](https://github.com/serenity-bdd/serenity-core/#what-is-the-latest-stable-version-i-should-use).

=== Working with Cucumber 2

To get started, you will need to add the Serenity Cucumber plugin to your project.
In Maven, just add the following dependencies to your pom.xml file:

[source,xml]
----
include::../examples/cucumber2-sample/pom.xml[tags=dependencies]
----

The equivalent in Gradle is:

[source,groovy]
----
include::../examples/cucumber2-sample/build.gradle[tags=dependencies]
----

=== Working with Cucumber 4

The Cucumber 4 dependency setup is a bit more complicated, as you need to override the Cucumber 2 dependency in Serenity core.
In Maven, you need add the following dependency configuration to your pom.xml file:

[source,xml]
----
include::../examples/cucumber4-sample/pom.xml[tags=dependencies]
----

The equivalent in Gradle is:

[source,groovy]
----
include::../examples/cucumber4-sample/build.gradle[tags=dependencies]
----

=== Using the Cucumber Maven Archetype

A Cucumber archetype for Cucumber 2 is available to help you jumpstart a new project.
As usual, you can run `mvn archetype:generate -Dfilter=serenity` from the command line
and then select the `net.serenity-bdd:serenity-cucumber-archetype` archetype from the proposed list of archetypes.
Or you can use your favorite IDE to generate a new Maven project using an archetype.

== Writing Executable Specifications with Cucumber and Serenity

In Cucumber, scenarios are stored in 'Feature Files', which contain an overall description of a feature as well as a number of scenarios.
The Feature File for the first example we saw earlier is called `cash_withdrawals.feature`, and looks something like this:

[source,gherkin]
----
include::../examples/cucumber2-sample/src/test/resources/features/bank/cash_withdrawals.feature
----

=== Organising your feature files

The simplest way to organise your Serenity/Cucumber feature files is to place them in the `src/test/resources/features` directory.

You typically organise the feature files in sub-directories that reflect the higher-level requirements.
You can think of each subdirectory as a chapter or section heading in your living documentation, with the features grouped inside these sections.
For example, in the following directory structure, we have feature definitions for several capabilities related to an online store, including 'search_for_products', 'make_a_purchase' and 'request_a_refund':

----
|----src
| |----test
| | |----resources
| | | |----features
| | | | |----search_for_products
| | | | | |----search.feature
| | | | |----make_a_purchase
| | | | | |----adding_items_to_the_shopping_cart.feature
| | | | | |----sales_tax.feature
| | | | | |----checkout.feature
| | | | |----request_a_refund
| | | | | |----refund_standard_purchases.feature
| | | | | |----refund_third_party_purchases.feature
----

=== The Scenario Runner

Cucumber runs the feature files via JUnit, and needs a dedicated test runner class to actually run the feature files.
When you run the tests with Serenity, you use the `CucumberWithSerenity` test runner.
You also need to use the `@CucumberOptions` class to provide the root directory where the feature files can be found.

A simple test runner looks like this:

[source,java]
----
include::../examples/cucumber-quick-start/src/test/java/net/serenity_bdd/samples/runners/CashWithdrawals.java[]
----
(1) Serenity Cucumber feature files need the `CucumberWithSerenity` test runner.
(2) The `features` attribute indicates where to look for the feature files
(3) The `glue` attribute tells Cucumber where to find the Step Definition classes

=== Cucumber Step definitions

In Cucumber, each line of the Gherkin scenario maps to a method in a Java class, known as a 'Step Definition'.
These use annotations like `@Given`, `@When` and `@Then` match lines in the scenario to Java methods.
In Cucumber 2, you define simple regular expressions to indicate parameters that will be passed into the methods:

[source,java]
----
public class CashWithdrawalsStepDefinitions {

    @Given("^(.*) has \\$(\\d+) in his (.*) account$")
    public void in_his_current_account(String customer, int balance, String accountType) {
    }

    @When("^he withdraws \\$(\\d+) in cash$")
    public void he_withdraws_$_in_cash(int withdrawal) {
    }

    @Then("^his remaining balance should be \\$(\\d+)$")
    public void his_remaining_balance_should_be(int expectedBalance) {
    }
}
----

In Cucumber 4, you can use regular expressions, but also the more readable https://cucumber.io/docs/cucumber/cucumber-expressions[Cucumber Expressions] notation shown below:

[source,java]
----
public class CashWithdrawalsStepDefinitions {

    @Given("{word} has ${int} in his {word} account")
    public void in_his_current_account(String customer, int balance, String accountType) {
    }

    @When("he withdraws ${int} in cash")
    public void he_withdraws_in_cash(int withdrawal) {
    }

    @Then("his remaining balance should be ${int}")
    public void his_remaining_balance_should_be(int expectedBalance) {
    }
}
----
=== Using Serenity step libraries in Cucumber Step definitions

It is perfectly possible to call classic test automation code directly in your step definition methods. In this case, Serenity will only report on the _Given..When..Then_ steps, and leave you full control of the underlying code.

Many teams however find it useful to organise their tests into reusable components and domain layer classes. And Serenity provides many ways to help with this.

Serenity Step Libraries integrate smoothly into Cucumber Step Definition files;
all you need to do is to annotate a step library variable with the `@Steps` annotation. For example, suppose our banking application has a set of web services to handle account balances and withdrawals. We could wrap these web service calls in Serenity Action classes, and inject these action classes into the step definition classes using the Serenity `@Steps` annotation, e.g.

[source,java]
----
public class CashWithdrawalsStepDefinitions {
    @Steps
    CreateAccountAction createAnAccount;

    @Given("{word} has ${int} in his {word} account")
    public void in_his_current_account(String customer,
                                       int balance,
                                       String accountType) {
        createAnAccount.forCustomer(customer)
                       .ofType(accountType)
                       .withABalanceOf(balance);
    }
    ...
}
----

The Action class uses a builder pattern for better readability.
We use the `@Step` annotation on the last method to ensure that we get a complete description of the step in our reports:

[source,java]
----
public class CreateAccountAction {
    String customerName;
    String accountType;

    public CreateAccountAction forCustomer(String customerName) {
        this.customerName = customerName;
        return this;
    }

    public CreateAccountAction ofType(String accountType) {
        this.accountType = accountType;
        return this;
    }

    @Step("Create a #accountType account for customer #customerName with a balance of ${0}")
    public int withABalanceOf(int balance) {
        // Call the appropriate web service and return the account unique ID
    }
}
----

The other step definition methods would use similar step libraries.
Some teams group their step libraries by theme or end point (for example, they might place all the web service calls related to managing a bank account in a single `BankAccountActions` step library). Others prefer to enforce a stricter separation of concerns, and have a single class per action (this approach is know as the _Action Classes_ pattern), as illustrated here:

[source,java]
----
public class CashWithdrawalsStepDefinitions {

    @Steps
    CreateAccountAction createAnAccount;

    @Steps
    WithdrawAction withdraw;

    @Steps
    AccountBalanceAction accountBalance;

    int accountIdentifier;

    @Given("{word} has ${int} in his {word} account")
    public void in_his_current_account(String customer, int balance, String accountType) {
        accountIdentifier = createAnAccount.forCustomer(customer).ofType(accountType).withABalanceOf(balance);
    }

    @When("he withdraws ${int} in cash")
    public void he_withdraws_in_cash(int withdrawal) {
        withdraw.fromAccount(accountIdentifier).theSumOf(withdrawal);
    }

    @Then("his remaining balance should be ${int}")
    public void his_remaining_balance_should_be(int expectedBalance) {
        assertThat(accountBalance.forAccount(accountIdentifier)).isEqualTo(expectedBalance);
    }
}
----

=== Integrating with Serenity Page Objects

Integration Cucumber with Serenity UI tests is also easy. Unlike with JUnit, you don't need to declare an `@Managed` WebDriver instance in your tests; Serenity will automatically instantiate a driver on demand.

For example, the following scenario is a very simple example of using a search engine:

[source,gherkin]
----
Feature: Search by keyword

  Scenario: Search for terms by a single keyword
    Given Serge is on the Search page
    When he searches by "Tomato"
    Then he should only see search results containing the word "Tomato"
----

We could use Serenity Page Objects or UI Action Classes to model the UI interactions.
For example, the following Serenity `PageObject` models the DuckDuckGo home page:

[source,java]
----
@DefaultUrl("https://duckduckgo.com")
public class SearchPage extends PageObject {

    public void searchBy(String keyword) {
        $("#search_form_input_homepage").sendKeys(keyword, Keys.ENTER);
    }
}
----

And this one allows us to query the search results:

[source,java]
----
public class ResultsPage extends PageObject {

    public List<String> getSearchResultTitles() {
        return findAll(".results .result__title")
                .stream()
                .map(WebElementFacade::getTextContent)
                .collect(Collectors.toList());
    }
}
----

We could use both of these page objects directly in our Cucumber step definition code, as shown here:

[source,java]
----
public class SearchStepDefinitions {

    SearchPage searchPage;
    ResultsPage resultsPage;

    @Given("Serge is on the Search page")
    public void serge_is_on_the_Search_page() {
        searchPage.open();
    }

    @When("he searches by {string}")
    public void he_searches_by(String keyword) {
        searchPage.searchBy(keyword);
    }

    @Then("he should only see search results containing the word {string}")
    public void he_should_only_see_search_results_containing_the_word(String expectedKeyword) {
        resultsPage.getSearchResultTitles().forEach(
                title -> assertThat(title).containsIgnoringCase(expectedKeyword)
        );
    }
}
----

Alternatively, we could use Action Classes or Step Libraries to encapsulate the UI logic.
In both cases, Serenity will instantiate the WebDriver instance for us the first time a page object is invoked.


=== Configuring Cucumber and Serenity

Serenity provides a number of configuration options when using Cucumber.

==== Maintaining the browser open for the entire feature

Reopening a browser session for each scenario can slow down your tests.
If you want Serenity to keep the browser open for the duration of a feature, you can set the following property in your `serenity.properties` or `serenity.conf` file:

[source,properties]
----
serenity.restart.for.each = feature
----

==== Maintaining state between scenarios

You may also wish to maintain state between scenarios.
By default, Serenity will use new step libraries and action classes for each scenario.
However, if you want to share data between the scenarios of a feature, you can use the following option:

[source,properties]
----
serenity.maintain.session = true
----

With this value set, you can now use either the `@Shared` annotation, or the `@Steps(shared=true)`. For example, suppose that the `CreateAccountAction` needs to retrieve a security token before making any calls, but that it only needs to do this once.
We could tell Serenity to maintain the same `CreateAccountAction` step library for all the scenarios in a feature file like this:

[source,java]
----
@Shared
CreateAccountAction createAnAccount;
----


=== Integrating with Serenity Screenplay

COMING SOON
