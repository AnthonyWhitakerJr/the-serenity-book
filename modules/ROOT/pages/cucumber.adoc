http://cucumber.io[Cucumber] is a popular tool for automating BDD-style acceptance criteria.
Teams that practice BDD have conversations about business rules and examples to better understand the problem they are solving.
Some of these examples can be transformed into automated acceptance criteria.
Teams that use Cucumber express these acceptance criteria in a natural, human-readable form using the `given..when..then` structure:

[source,gherkin]
----
Scenario: Cash withdrawal
  Given Clive has $1000 in his current account
  When he withdraws $100 in cash
  Then his remaining balance should be $900
----

This format is known as 'Gherkin', and is widely used in Cucumber and other Cucumber-based BDD tools such as SpecFlow (for .NET) and Behave (for Python).
Gherkin is a flexible, highly readable format that can be written collaboratively with product owners to ensure that everyone is on the same page.
The loosely-structured 'Given-When-Then' format helps people focus on what they are trying to achieve, and how they will know when they get it.

Gherkin also supports tabular data formats, which is a useful and concise way of representing many domain concepts:

[source,gherkin]
----
Scenario: Transferring funds between internal accounts
  Given Clive has the following accounts:
    | Account | Balance |
    | Current | 1000    |
    | Savings | 2000    |
  When he transfers $100 from his Current account to his Savings account
  Then his new account balances should be:
    | Account | Balance |
    | Current | 900     |
    | Savings | 2100    |
----

Sometimes tables can be used to summarise several different examples of the same scenario.
For example, the following scenario illustrates the fee structure for different account types:

[source,gherkin]
----
Scenario Outline: Account Fees for different types of account
  Given Clive has an <Account Type> account with a balance of <Sample Balance>
  When the monthly fees are calculated
  Then a <Monthly Fee> monthly fee of <Sample Fee> should be deducted
  Examples:
  | Account Type | Monthly Fee | Sample Balance | Sample Fee |
  | Current      | $1.50       | 1000           | 1.50       |
  | Savings      | $0.00       | 1000           | 0.00       |
  | Investment   | 0.25%       | 1000           | 2.50       |
----

When you integrate Serenity with Cucumber,

== Versions of Cucumber

There are currently two commonly-used versions of Cucumber: Cucumber 2 and Cucumber 4.
While they both support the same _Gherkin_ notation, the way you implement the steps is a little different in each version.
When you use Serenity with Cucumber, you use a different dependency depending on the version of Cucumber you want to use.

New versions come out regularly: you can find out what the latest stable versions are [on the Serenity BDD Github home page](https://github.com/serenity-bdd/serenity-core/#what-is-the-latest-stable-version-i-should-use).

=== Working with Cucumber 2

To get started, you will need to add the Serenity Cucumber plugin to your project.
In Maven, just add the following dependencies to your pom.xml file:

[source,xml]
----
include::../examples/cucumber2-sample/pom.xml[tags=dependencies]
----

The equivalent in Gradle is:

[source,groovy]
----
include::../examples/cucumber2-sample/build.gradle[tags=dependencies]
----

=== Working with Cucumber 4

The Cucumber 4 dependency setup is a bit more complicated, as you need to override the Cucumber 2 dependency in Serenity core.
In Maven, you need add the following dependency configuration to your pom.xml file:

[source,xml]
----
include::../examples/cucumber4-sample/pom.xml[tags=dependencies]
----

The equivalent in Gradle is:

[source,groovy]
----
include::../examples/cucumber4-sample/build.gradle[tags=dependencies]
----

=== Using the Cucumber Maven Archetype

A Cucumber archetype for Cucumber 2 is available to help you jumpstart a new project.
As usual, you can run `mvn archetype:generate -Dfilter=serenity` from the command line
and then select the `net.serenity-bdd:serenity-cucumber-archetype` archetype from the proposed list of archetypes.
Or you can use your favorite IDE to generate a new Maven project using an archetype.

== Writing Executable Specifications with Cucumber and Serenity

In Cucumber, scenarios are stored in 'Feature Files', which contain an overall description of a feature as well as a number of scenarios.
The Feature File for the first example we saw earlier is called `cash_withdrawals.feature`, and looks something like this:

[source,gherkin]
----
include::../examples/cucumber2-sample/src/test/resources/features/bank/cash_withdrawals.feature
----

=== Organising your feature files

The simplest way to organise your Serenity/Cucumber feature files is to place them in the `src/test/resources/features` directory.

You typically organise the feature files in sub-directories that reflect the higher-level requirements.
You can think of each subdirectory as a chapter or section heading in your living documentation, with the features grouped inside these sections.
For example, in the following directory structure, we have feature definitions for several capabilities related to an online store, including 'search_for_products', 'make_a_purchase' and 'request_a_refund':

----
|----src
| |----test
| | |----resources
| | | |----features
| | | | |----search_for_products
| | | | | |----search.feature
| | | | |----make_a_purchase
| | | | | |----adding_items_to_the_shopping_cart.feature
| | | | | |----sales_tax.feature
| | | | | |----checkout.feature
| | | | |----request_a_refund
| | | | | |----refund_standard_purchases.feature
| | | | | |----refund_third_party_purchases.feature
----

=== The Scenario Runner

Cucumber runs the feature files via JUnit, and needs a dedicated test runner class to actually run the feature files.
When you run the tests with Serenity, you use the `CucumberWithSerenity` test runner.
You also need to use the `@CucumberOptions` class to provide the root directory where the feature files can be found.

A simple test runner looks like this:

[source,java]
----
include::../examples/cucumber-quick-start/src/test/java/net/serenity_bdd/samples/runners/CashWithdrawals.java[]
----
(1) Serenity Cucumber feature files need the `CucumberWithSerenity` test runner.
(2) The `features` attribute indicates where to look for the feature files
(3) The `glue` attribute tells Cucumber where to find the Step Definition classes

=== Step definitions

In Cucumber, each line of the Gherkin scenario maps to a method in a Java class, known as a 'Step Definition'.
These use annotations like `@Given`, `@When` and `@Then` match lines in the scenario to Java methods.
In Cucumber 2, you define simple regular expressions to indicate parameters that will be passed into the methods:

[source,java]
----
public class CashWithdrawalsStepDefinitions {

    @Given("^(.*) has \\$(\\d+) in his (.*) account$")
    public void in_his_current_account(String customer, int balance, String accountType) {
    }

    @When("^he withdraws \\$(\\d+) in cash$")
    public void he_withdraws_$_in_cash(int withdrawal) {
    }

    @Then("^his remaining balance should be \\$(\\d+)$")
    public void his_remaining_balance_should_be(int expectedBalance) {
    }
}
----

In Cucumber 4, you can use regular expressions, but also the more readable https://cucumber.io/docs/cucumber/cucumber-expressions[Cucumber Expressions] notation shown below:

[source,java]
----
public class CashWithdrawalsStepDefinitions {

    @Given("{word} has ${int} in his {word} account")
    public void in_his_current_account(String customer, int balance, String accountType) {
    }

    @When("he withdraws ${int} in cash")
    public void he_withdraws_in_cash(int withdrawal) {
    }

    @Then("his remaining balance should be ${int}")
    public void his_remaining_balance_should_be(int expectedBalance) {
    }
}
----

=== Integrating with Serenity Step Libraries and Action Classes

=== Integrating with Serenity Page Objects

=== Maintaining the browser open for the entire feature

=== Maintaining state between scenarios
